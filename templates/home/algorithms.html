{% extends 'base.html' %}

{% block content %}

<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container-fluid">
        <a class="navbar-brand" href="#">
            <img src="{{ url_for('static', filename='icon.svg') }}" width="60", height="45">
        </a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
            <div class="navbar-nav">
            <a class="nav-link" aria-current="page" href="{{ url_for('index') }}">Home</a>
            <a class="nav-link" href="{{ url_for('about') }}">About</a>
            <a class="nav-link active" href="#">Algorithms</a>
            <a class="nav-link" href="https://github.com/DuncanCarlmark/DSC180b-Capstone" >Repo</a>
            </div>
        </div>
    </div>
</nav>


<div class="container">
    <div class="row justify-content-center">
        <h1 class="w-75" style="text-align: center;">Task 0:</h1>

        <p class="w-75">
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For this sample recommender, we use a TopPopular recommender where we rank the “popularity” of each song in 
            the Billboard dataset and return the most popular songs. All songs in Billboard are filtered first by their 
            release dates: we assumed the relevant timeframe for the parent’s age to be from when they were 15 years old, 
            to when they were 30 years old based on the premise that an individual’s music preference is determined around 
            age 15 and that they stop listening to new songs by the age of 30 [1]. The songs are then filtered by the 
            parent’s preferred genres and artists, and ordered by their popularity, which is determined by three statistics: 
            instance, average weekly position, and the number of weeks the song was on the chart. The songs are ordered by 
            lowest instance, lowest average weekly position and highest number of weeks to exclude seasonal songs like 
            Christmas carols with high instance values, and prioritize songs that were ranked higher on the chart for longer. 
            The final output contains the top 20 songs that take the parent’s input into account
        </p>

        <br>
        <hr>

        <h1 class="w-75" style="text-align: center;">Task 1:</h1>

        <p class="w-75">
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The parent-to-user recommender uses a hybrid approach, meaning that it uses both collaborative filtering (CF) 
            and content-based filtering (CBF) techniques to recommend songs. We decided not to rely solely on CF methods unlike 
            our user-to-parent recommender, due to the LastFM dataset having a limited number of users aged over 40, which is 
            where our parents are more likely to fit in.

        </p>

        <p class="w-75">
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The CF part of this hybrid recommender uses LightFM [2], a Python library using matrix factorization for implicit 
            and explicit feedback. Using Spotipy, which is the Python library for Spotify’s Web API, we get the parent’s top 50 
            tracks on Spotify, get the artist for each track as well as the number of songs each artist had produced in the 50 
            songs. The LastFM data also contains each user’s listening frequency for each artist, so we use this frequency as the 
            ‘weight’ for each item, meaning that the artist that is more listened to by the parent would be of more importance. We
             decided to use LightFM for the CBF part of this model as it uses latent representation to address the cold-start 
             problem by grouping items that are liked by the same users, even if the items do not share similar features. To reduce 
             the amount of data we work with and to improve the recommender’s performance, we ask the parent for their 
             user/children’s age and only get LastFM data within a similar age range as the user, getting users that are up to 2 
             years younger or older than the child user. Each user-artist interaction in both the parent’s listening history as 
             well as the LastFM data is a positive interaction (instead of a negative interaction, where a user specifies that 
             they did not like the item) used to build LightFM’s recommender model, which also stores every user and artist in the 
             interactions. LightFM essentially works by representing each user and item fed into the model as the sum of latent 
             representation, and finding the dot product of those representations using the equation rui = f (qu · pi+ bu + bi), 
             with qu representing the user’s latent representation (= sum of latent vectors), pi representing the item’s latent 
             representation, and with bu and bi each representing bias terms for the user and the item. We chose WARP (Weighted 
             Approximate-Rank Pairwise) for the loss function as it resulted in a higher AUC than BPR (Bayesian Personalized 
             Ranking), the only other loss function suitable for having only positive interactions available as data. For each 
             user in the model, the artists are ranked by the dot product; we get the artists with the highest dot product value 
             as an output from this model.
        </p>

        <p class="w-75">
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Although LightFM has CBF functionality, we found out that its item features implementation does not work properly 
            and could not be used for CBF. Thus, for the CBF part of this recommender, we decided to use euclidean distance to 
            calculate the distance between other songs and the parent’s top tracks, using their audio features from Spotify. 
            From the LightFM’s output list of artists (the number of artists is defaulted to 10 for convenience, since Spotify’s 
            API only allows pulling audio information for up to 100 songs at a time), we get the top 10 popular songs from each 
            artist and compile a list of 100 songs. Then we calculate the euclidean distance between those songs and the parent’s 
            preferred songs, using the formula d(p,q) = i=111(qi-pi)2, where pi and qi are the ith audio features from arbitrary
             song p and parent’s song q, from 11 features: danceability, energy, key, loudness, mode, speechiness,  acousticness,
              instrumentalness, liveness, valence, and tempo. We get the minimum Euclidean distance for each song in the 
              recommended list from all of the parent’s songs, and rank the songs by their shortest distance from any parent’s 
              song. The final output is a list of songs ordered by ascending euclidean distance, to recommend songs that are most 
              similar to the parent’s preferred songs in terms of audio features to the user.

        </p>
        
        <br>
        <hr>

        <h1 class="w-75" style="text-align: center;">Task 2:</h1>

        <p class="w-75">
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We implement Implicit using alternating least squares to build similarity between the user’s playlist information 
            and older users (users in the parent’s age range) in the LastFM dataset. For our implicit feedback model, we use plays (number of interactions) as our “rating.” Once we fit the model, we 
            can now build recommendations for the particular user, in this case the user who has requested a playlist for their parent, and a list 
            of recommended artists is returned. In our initial responses collected by the user, we collected the parent’s favored genres so we use 
            that data to filter down the recommended artists. We use Spotipy, which is a Python library for the Spotify Web API, to collect the 
            genre for each artist and we then filter the list of recommended artists down to artists that are represented by the favored genre of 
            the parent. We can then use Spotify’s top tracks to build a playlist from these filtered recommended artists to get a final list of 
            songs that is outputted to a playlist on the user’s Spotify account. 

        </p>

    </div>
    
    <br>
    <br>
   
</div>

{% endblock %}